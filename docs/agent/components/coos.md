# 協調型OS COOS

## 概要

COOSは、シングルスレッド環境向けのホーアCSPベースのグリーンスレッドである。


## 仕組み

- グリーンスレッドはコルーチンを用いて実装される。
- コルーチンによるタスクが複数登録され、ラウンドロビンスケジューラーにより実行される。
- タスクは割り込みを入れて良いタイミングで自らco_yieldし制御を渡す。

## 構成要素

COOSは以下の構成要素を持つ。

- co_sched
  - 協調的スケジューリング
- co_csp
  - ホーアCSPによる同期通信メカニズム
- co_mem
  - dlmallocベースメモリ管理
- co_value
  - 所有権付き共有メモリ

## co_sched

- タスクはC++20のコルーチンで実装する。
- ラウンドロビンスケジューラ。スケジューラにタスクを登録することでそれがラウンドロビンスケジュールされる。
- タスクがスケジューラに登録されるとタスクIDが採番される。
- タスクごとにスケジューラが専用のco_memを割り当てる。
- スケジューラから現在実行中のタスクの情報を取得することができる。

## co_csp

- COOSはホーアCSPに基づいたタスク間通信、同期メカニズムを持つ。
- COOSは同期オブジェクトはCSP以外は持たない。
- チャンネルは通信データを保存する通信バッファを持つ。
- ブロッキングI/Oであるため通信バッファはひとつのエントリしか持たない。
- 通信バッファサイズはチャンネルで通信する型で決まる。

## co_mem

- タスクのスタック、ヒープはco_memで管理される。
- タスクの登録時に対応するco_memを割り当てる。
  - タスクに割り当てるヒープは @docs/agent/architecture/overview.md を参照すること。
- new、delete演算子はオーバーロードされ、現在実行中のタスクのco_memが使われる。

## co_value

- タスク間でメモリブロックを移動する場合はco_valueが用いられる。
- co_valueでどのタスクがメモリブロックを排他的に所有するか管理する。
- co_cspでco_valueを渡す場合はムーブセマンティクスで所有権を相手に渡さないといけない。
- 所有権の概念によりco_valueはタスク間で共有されることがない。
- 所有権を持たないタスクがco_valueにアクセスするとエラーとなる。
- RAIIパターンを使用し、所有権を持つタスクは変数のスコープを抜けるときに共有メモリを解放する。
