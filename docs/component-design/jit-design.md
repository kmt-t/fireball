# Fireball JIT コンパイラ設計

**Version:** 0.2.0  
**Date:** 2025-12-02  
**Author:** Takuya Matsunaga / Cline (補完)

---

## 概要

Fireball JIT コンパイラは、WebAssembly モジュールのホットパス加速を目的としたバックグラウンドコンパイルシステムです。インタプリタは実行を継続しつつ、JIT が非同期でコンパイルを行い、低レイテンシかつ検証可能なネイティブコードを提供します。

本設計は既存の `docs/component-design/jit-design.md` を拡張し、特に「テンプレートをヒープに展開しパッチを当てる方式（テンプレート展開＋パッチ）」の具体的手順、制約、そして検証計画を明確にします。JIT の目的は厳格に以下の二点に限定されます。

- ① 命令のデコードの削除（インタプリタのデコードオーバーヘッド排除）  
- ② 分岐予測が外れる可能性が高い分岐の除去（ミス予測コスト低減）

JIT は基本的な算術演算を除き、分岐予測が効くランタイムAPI呼び出し（vSoC 呼び出しなど）をコンパイルするに留め、複雑な機械語最適化は行いません。具体的な生成方式は「テンプレート展開＋パッチ当て」を採用します。

---

## 1. アーキテクチャ（要約）

（既存内容を踏襲）
- JIT は vSoC 内蔵、バックグラウンドコルーチンで動作
- ホットパス追跡 → コンパイル要求キュー → バックグラウンドワーカーでコンパイル → コンパイル済みコードをキャッシュ
- インタープリタは待たない（非プリエンプティブ）

---

## 2. 目的とスコープ（明確化）

- 目的: 命令デコード削除と高ミス分岐除去による低レイテンシ化。
- スコープ（何をやるか／やらないか）:
  - 行う: テンプレート展開＋パッチでのコード生成、基本算術命令のインライン、分岐の再構成（条件反転、予測に依存した順序化など）。
  - 行わない: 高度な数値最適化（ループ変換、自動ベクトル化等）、アグレッシブなインライン拡張による大規模最適化。

---

## 3. テンプレート展開＋パッチ方式（詳細）

### 3.1 概要
JIT は「コードテンプレート（prebuilt binary sequences）」をライブラリとして保持し、コンパイル対象関数の構造に合わせてテンプレートをヒープ上に展開し、固定箇所（オフセット）に対して必要なパッチ（定数置換、アドレス書換、分岐先書換）を行うことでネイティブ実行可能なコードを生成します。

この方式の利点:
- 生成パスがシンプルで検証が容易
- 高度なバックエンド最適化が不要なため設計リスクが低い
- 生成レイテンシが小さく抑えられる

### 3.2 構成要素
- テンプレートライブラリ: CPU アーキテクチャ別（ARM Thumb-2 / RISC-V）に用意された小さなバイナリスニペット集合
- テンプレートメタデータ: 各テンプレートのパッチ可能オフセット、定数型（32bit/64bit）、分岐ラベル情報
- 展開エンジン: ヒープにテンプレートをコピーし、パッチを適用して実行可能領域へ配置
- パッチテーブル: パッチ箇所と置換データのリスト
- 検証モジュール: 生成コードの整合性チェック（サニティチェック、hash 検証）

### 3.3 テンプレート設計ガイドライン
- テンプレートは短く、単一責務（例: 加算／ロード／ストア／呼び出しラッパー）
- 分岐はテンプレート内で現実的に扱える形に限定（条件フラグの読み書きを外部化）
- テンプレートはアラインメント済みで、パッチ可能な箇所は明確にマーク
- テンプレートメタデータはバージョン管理（テンプレート版）を付与

### 3.4 展開手順（アルゴリズム）
1. コンパイル要求を dequeuing → function/pc を取得
2. 関数のバイトコード解析（簡易）：命令ストリームを解析し、テンプレートの組合せを決定（テンプレートマッチング）
3. テンプレートヒープ展開:
   - 必要テンプレートを順にヒープ上へ memcpy
   - メタデータに基づきパッチ箇所を記録
4. パッチ適用:
   - 定数（immediate）、アドレス、分岐先オフセットを書き込む
   - 呼び出し先は vSoC のエントリーポイントへ直接分岐指示に置換（分岐予測を意識）
5. 生成コードの整合性チェック:
   - サニティチェック（整合的アドレス、命令エンコーディングの妥当性）
   - Optional: 簡易ハッシュ / CRC を計算して維持
6. キャッシュ挿入:
   - compiled_code_cache に挿入（LRU 方針）
7. インタプリタへの切替え:
   - 次回実行時に lookup で見つかればネイティブコードへ分岐（ジャンプテーブルで切替え）

### 3.5 パッチの種類（例）
- Immediate constant 書換（定数乗算の係数等）
- 分岐先アドレス書換（relative jump target）
- データポインタ置換（ロード元アドレス）
- 呼び出しラッパーの差替え（vSoC 経由の syscalls を直接呼ぶ短絡コードへ）

### 3.6 実行メモリ管理
- 生成コードは実行可能ページ（RX）へ配置。配置時にキャッシュフラッシュ（ICache）/同期を行う。
- 生成領域は code_cache が管理。解放時はページを無効化して再利用。

---

## 4. コンパイル制御ポリシー（安全策）

- コンパイルキューサイズ・同時コンパイル数を制限（デフォルト: キュー 32, ワーカー 1-2）
- コンパイルはインタプリタ優先。バックグラウンドで実行し、ユーザータスクのレイテンシを阻害しない。
- 生成コードのメモリ上限（合計サイズ）を設け、超過時は LRU でエビクト。
- 生成コードは read-only + execute 権限で配置。書き換えは不可（整合性保証）。
- 失敗時は明示的にフォールバック（インタプリタに戻す）。ただし設計としてはフォールバック発生が稀なことを目標とする。

---

## 5. テスト・検証計画（Verification Plan）

目的: JIT の安全性・整合性・性能改善を事前に検証し、設計リスクを排除する。

### 5.1 単体テスト（Unit）
- テンプレート展開ユニット: 各テンプレートのパッチ処理検証（境界値、異常値）
- パッチ適用ユニット: オフセット整合性、書込後の命令バイナリ検査
- サニティチェック: 不正なアドレス/オフセットを検出するテスト

### 5.2 統合テスト（Integration）
- インタプリタ＋JIT 統合シナリオ:
  - 小関数のヒント→コンパイル→実行切替が正しく行われる
  - vSoC 呼び出しを含む関数の JIT 化と実行検証
- エラー注入テスト:
  - コンパイル中断、テンプレート不足、パッチ不整合時に正しくフォールバックする

### 5.3 回帰テスト（Regression）
- 既存のインタプリタ実行が JIT によって壊れないことを確認
- JIT の有効/無効切替テストスイート

### 5.4 性能テスト（Performance）
- ベンチマークセット: 代表的な小・中・大関数でコンパイル前後の実行時間比較
- レイテンシ計測: JIT キューイング時間、バックグラウンドコンパイル時間、切替オーバーヘッド
- メモリ測定: code_cache 使用量、テンプレートヒープ使用量

### 5.5 セキュリティ・堅牢性テスト
- 不正入力（破壊的 WASM）に対する JIT の耐性（サニティチェック）
- 実行可能領域の実行権限チェック、改ざん検出

### 5.6 フォーマル/静的解析（可能な範囲で）
- テンプレートメタデータの整合性チェックを静的解析で検証
- 生成ロジックに対するトレースベースの形式検証（重要箇所）

### 5.7 テスト自動化
- CI パイプラインにユニット・統合・性能テストを組込む
- 必須: nightly ビルドで JIT を有効にしたテストを回す（レグレッション検出）

---

## 6. 受入基準（Acceptance Criteria）

- JIT 適用後の機能合致: 生成コードでの結果がインタプリタ実行と一致（全テストパス成功）
- レイテンシ向上: 代表ベンチにて 1.5x 以上の高速化（O0 前提）を確認（ケースに依る）
- レイテンシデグレ: JIT がオンであっても短期的なレイテンシがインタプリタ比で劣化しないこと（例: p99 レイテンシ差 < 5%）
- 整合性: 生成コードのサニティ検査に合格、CI で自動検証
- メモリ制約: code_cache + templates の合計がプラットフォーム予算内に収まること（例: 16KB ターゲット）

---

## 7. リスクと緩和策

- リスク: テンプレート不一致やパッチミスによる実行崩壊  
  緩和: 厳格なサニティチェック、CI テスト、生成コードの checksum 検査
- リスク: JIT のコンパイルレイテンシが高く、バックグラウンドでシステムを圧迫  
  緩和: コンパイル QoS（ワーカー数/優先度制御）、キューサイズ制限、低優先度実行
- リスク: コード注入・改ざん  
  緩和: 実行可能領域の権限付与の最小化、生成時の検証
- リスク: 検証不足による仕様逸脱  
  緩和: 自動テストカバレッジ目標の設定、性能/回帰テストを必須化

---

## 8. 実装チェックリスト（更新）

- [ ] テンプレートライブラリ定義（ARM / RISC-V）
- [ ] テンプレートメタデータフォーマット
- [ ] テンプレート展開エンジン（ヒープ展開、パッチ適用）
- [ ] サニティ検証モジュール
- [ ] compiled_code_cache 実装（挿入・検索・evict）
- [ ] バックグラウンドコンパイルワーカー実装
- [ ] builtin_jit_* 組込みAPI実装
- [ ] CI テストの整備（ユニット・統合・性能）
- [ ] ドキュメント（開発者向け）: テンプレート作成ガイド、パッチルール

---

## 9. 参考資料
- docs/specifications/overview.md — JIT の高レベル方針（ADR-005）
- docs/analysis/safety-model.md — Safety Model と ISR/JIT のインタラクション
- docs/component-design/vsoc.md — vSoC の設計（参照）
- ARM/RISC-V コード生成参考資料（内部リンク）

---

## 10. 付録: テンプレートメタデータ 例

```json
{
  "template_id": "load_call_wrapper_v1",
  "arch": "arm-thumb2",
  "size": 48,
  "patch_points": [
    { "offset": 8, "type": "imm32" },
    { "offset": 20, "type": "rel_jmp" },
    { "offset": 32, "type": "addr32" }
  ],
  "version": 1
}
```

---
