<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>overview</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">overview</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#fireball-architecture-overview"
id="toc-fireball-architecture-overview">Fireball Architecture
Overview</a>
<ul>
<li><a href="#overview" id="toc-overview">Overview</a></li>
<li><a href="#system-layers" id="toc-system-layers">1. System
Layers</a></li>
<li><a href="#component-dependencies" id="toc-component-dependencies">2.
Component Dependencies</a>
<ul>
<li><a href="#runtime-embedded-functionsパフォーマンス最適化設計"
id="toc-runtime-embedded-functionsパフォーマンス最適化設計">2.1
Runtime-Embedded Functions（パフォーマンス最適化設計）</a></li>
</ul></li>
<li><a href="#data-flow" id="toc-data-flow">3. Data Flow</a>
<ul>
<li><a href="#coroutine-lifecycle" id="toc-coroutine-lifecycle">3.1
Coroutine Lifecycle</a></li>
<li><a href="#channel-communication" id="toc-channel-communication">3.2
Channel Communication</a></li>
<li><a href="#memory-allocation" id="toc-memory-allocation">3.3 Memory
Allocation</a></li>
</ul></li>
<li><a href="#concurrency-model" id="toc-concurrency-model">4.
Concurrency Model</a>
<ul>
<li><a href="#csp-synchronization" id="toc-csp-synchronization">4.2 CSP
Synchronization</a></li>
</ul></li>
<li><a href="#memory-layout" id="toc-memory-layout">5. Memory Layout</a>
<ul>
<li><a href="#coroutine-stack" id="toc-coroutine-stack">5.2 Coroutine
Stack</a></li>
</ul></li>
<li><a href="#build-artifacts" id="toc-build-artifacts">6. Build
Artifacts</a>
<ul>
<li><a href="#executable-structure" id="toc-executable-structure">6.2
Executable Structure</a></li>
</ul></li>
<li><a href="#execution-model" id="toc-execution-model">7. Execution
Model</a>
<ul>
<li><a href="#startup-sequence" id="toc-startup-sequence">7.1 Startup
Sequence</a></li>
<li><a href="#event-loop-execution" id="toc-event-loop-execution">7.2
Event Loop Execution</a></li>
</ul></li>
<li><a href="#error-handling" id="toc-error-handling">8. Error
Handling</a>
<ul>
<li><a href="#debug-support" id="toc-debug-support">8.2 Debug
Support</a></li>
</ul></li>
<li><a href="#performance-considerations"
id="toc-performance-considerations">9. Performance Considerations</a>
<ul>
<li><a href="#context-switch-cost" id="toc-context-switch-cost">9.1
Context Switch Cost</a></li>
<li><a href="#channel-sendreceive-cost"
id="toc-channel-sendreceive-cost">9.2 Channel Send/Receive Cost</a></li>
<li><a href="#memory-overhead" id="toc-memory-overhead">9.3 Memory
Overhead</a></li>
</ul></li>
<li><a href="#target-device-constraints"
id="toc-target-device-constraints">10. Target Device Constraints</a>
<ul>
<li><a href="#platform-target-strategy"
id="toc-platform-target-strategy">Platform Target Strategy</a></li>
<li><a href="#wch-ch32v307-tier-1-primary"
id="toc-wch-ch32v307-tier-1-primary">10.1 WCH CH32V307 (Tier 1
Primary)</a></li>
<li><a href="#nordic-nrf52840-tier-2-wireless"
id="toc-nordic-nrf52840-tier-2-wireless">10.2 Nordic nRF52840 (Tier 2
Wireless)</a></li>
</ul></li>
<li><a href="#architectural-decision-records-adr"
id="toc-architectural-decision-records-adr">Architectural Decision
Records (ADR)</a>
<ul>
<li><a href="#adr-001-multi-guest-support"
id="toc-adr-001-multi-guest-support">ADR-001: Multi-Guest
Support</a></li>
<li><a href="#adr-002-isr-safety-mechanism"
id="toc-adr-002-isr-safety-mechanism">ADR-002: ISR Safety
Mechanism</a></li>
<li><a href="#adr-003-memory-partitioning"
id="toc-adr-003-memory-partitioning">ADR-003: Memory
Partitioning</a></li>
<li><a href="#adr-004-maximum-coroutines-configuration"
id="toc-adr-004-maximum-coroutines-configuration">ADR-004: Maximum
Coroutines Configuration</a></li>
<li><a href="#adr-005-jit-fallback-strategy"
id="toc-adr-005-jit-fallback-strategy">ADR-005: JIT Fallback
Strategy</a></li>
</ul></li>
<li><a href="#future-architecture-changes"
id="toc-future-architecture-changes">11. Future Architecture Changes</a>
<ul>
<li><a href="#potential-optimizations"
id="toc-potential-optimizations">11.1 Potential Optimizations</a></li>
<li><a href="#scalability" id="toc-scalability">11.2
Scalability</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<h1 id="fireball-architecture-overview">Fireball Architecture
Overview</h1>
<p><strong>Version:</strong> 0.1.0 <strong>Date:</strong> 2025-11-28
<strong>Author:</strong> Takuya Matsunaga</p>
<hr />
<h2 id="overview">Overview</h2>
<p>Fireball は、リソース制約のある組み込みシステム向けの WebAssembly
ハイパーバイザーです。本ドキュメントは、Fireball
システム全体のアーキテクチャ、各コンポーネント間の依存関係、データフロー、メモリレイアウト、パフォーマンス特性を詳細に説明します。</p>
<p><strong>核となる設計思想：</strong></p>
<ul>
<li><strong>マイクロカーネル設計</strong>: COOS（Cooperative Operating
System）カーネルは最小限の 4 つのコンポーネント（スケジューラー、CSP
チャネル、メモリ管理、値の所有権追跡）のみで構成。ロギング、ハードウェア管理、デバッグなどはサービスレイヤーとして独立</li>
<li><strong>協調的マルチタスク</strong>:
プリエンプティブなタイマー割り込みを使用せず、コルーチンが明示的に制御を譲り合う方式。これにより複雑なロック機構を排除</li>
<li><strong>CSP による通信</strong>:
チャネルを通じた同期通信が唯一の同期機構。「メモリ共有による通信をするな；通信によってメモリを共有せよ」というホーアの原理に従う</li>
<li><strong>メモリ隔離</strong>: 各 WASM
モジュールは独立したメモリスペースを持ち、ヒープ枯渇が他モジュールに波及しない</li>
</ul>
<p>以降では、システムレイヤー構成、コンポーネント依存関係、データフロー、メモリレイアウト、パフォーマンス特性を順に説明します。</p>
<hr />
<h2 id="system-layers">1. System Layers</h2>
<p>Fireball は、下記の 6
つのレイヤーから構成されています。各レイヤーは明確な責務を持ち、下位のレイヤーのみに依存します（逆方向の依存はない）。</p>
<p><strong>レイヤーの役割分担：</strong></p>
<ol type="1">
<li><strong>WebAssembly Guest Modules</strong>: ユーザーが提供する WASM
バイナリコード（アプリケーション層）</li>
<li><strong>Virtual System-on-Chip (vSoC)</strong>: 仮想 SoC
の中核実行エンジン。Interpreter（i32 命令セット実行）+
JIT（最適化実行）を統合。vOffloader（アクセラレータ・システムコール）を
MMIO マッピング。
<ul>
<li><strong>主要実行</strong>: vSoC が命令実行の中心</li>
<li><strong>従要素</strong>: Interpreter は vSoC の命令セット実装、JIT
は最適化モジュール</li>
<li><strong>周辺</strong>: vOffloader は MMIO
でマッピングされ、ネイティブ BLAS
などのアクセラレータとシステムコールを提供</li>
</ul></li>
<li><strong>COOS Kernel Core</strong>: 協調的スケジューリング、CSP
チャネル、メモリ割り当て、値の所有権追跡（最小限のカーネル）</li>
<li><strong>Subsystems &amp; Services Layer</strong>:
<ul>
<li><strong>Router (DI Container)</strong>: URI
ベースルーティング、アクセス制御、コンポーネント登録（依存性注入）</li>
<li><strong>Subsystems (ネイティブ実装)</strong>:
ロギング（logger）、ハードウェア抽象化（hal）、デバッグ</li>
<li><strong>Services (WASM プラグイン)</strong>: ユーザー提供の WASM
サービス実装</li>
</ul></li>
<li><strong>HAL Backend</strong>: UART、GPIO、I2C、SPI、Timer
などのドライバ実装（プラットフォーム固有）</li>
<li><strong>Hardware</strong>: ARM Cortex-M / RISC-V / x86 (for
testing)</li>
</ol>
<p>以下は、システム全体のレイヤー構成を視覚化したものです。矢印は制御フロー（上から下への呼び出し）を示します。</p>
<pre><code>┌──────────────────────────────────────────────────────────────┐
│                  WebAssembly Guest Modules                    │
│                     (user code)                               │
└──────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌──────────────────────────────────────────────────────────────┐
│             Virtual System-on-Chip (vSoC)                     │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐       │
│  │    Module    │  │ Interpreter  │  │   Linear    │       │
│  │    Loader    │  │  (i32 core)  │  │   Memory    │       │
│  └──────────────┘  ├──────────────┤  └──────────────┘       │
│                    │ JIT Compiler │                         │
│                    │  (Optional)  │                         │
│                    └──────────────┘                         │
└──────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌──────────────────────────────────────────────────────────────┐
│  COOS Kernel Core（最小限の4コンポーネント）                │
│                                                               │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  co_sched (Scheduler)                              │   │
│  │  co_csp (CSP Channels)                             │   │
│  │  co_mem (Memory Allocator)                         │   │
│  │  co_value (Ownership Tracking)                     │   │
│  └─────────────────────────────────────────────────────┘   │
└──────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌──────────────────────────────────────────────────────────────┐
│  Subsystems &amp; Services Layer（COOS非依存、IPC通信）         │
│                                                               │
│        ┌─────────────────────────────────┐                  │
│        │   Router ★ (DI Container)       │                  │
│        │   - URI-based routing           │                  │
│        │   - Access control              │                  │
│        └────────────┬─────────────────────┘                  │
│                     │                                        │
│     ┌───────────────┼───────────────────┐                   │
│     │               │                   │                   │
│     ▼               ▼                   ▼                   │
│ ┌─────────┐   ┌──────────────┐   ┌──────────────┐          │
│ │ logger  │   │   hal        │   │  Services    │          │
│ └─────────┘   │(HAL bridge)  │   │  (WASM)      │          │
│               └──────────────┘   └──────────────┘          │
│ ┌─────────┐                                                │
│ │debugger │                                                │
│ │[Phase3] │                                                │
│ └─────────┘                                                │
│                                                               │
│  ★ Router: DI Container + URI routing                       │
└──────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌──────────────────────────────────────────────────────────────┐
│    Hardware Abstraction Layer (HAL Backend)                   │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐    │
│  │  UART    │  │   GPIO   │  │   I2C    │  │  Timer   │    │
│  │  Driver  │  │  Driver  │  │  Driver  │  │  Driver  │    │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘    │
└──────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌──────────────────────────────────────────────────────────────┐
│                      Hardware                                 │
│  ARM Cortex-M / RISC-V / x86 (for testing)                  │
└──────────────────────────────────────────────────────────────┘</code></pre>
<h2 id="component-dependencies">2. Component Dependencies</h2>
<p>Fireball
の設計では、<strong>依存関係が明確で循環参照がない</strong>ことが重要です。これにより、各コンポーネントを独立にテストでき、変更による影響を局所化できます。</p>
<p>以下は、COOS カーネルコアと Subsystems &amp; Services Layer
における依存関係を示したものです。</p>
<p><strong>重要な設計原則：</strong></p>
<ul>
<li><strong>COOS カーネルコア</strong>: 4
つのコンポーネント間に依存関係がありますが、循環参照はありません。スケジューラーはメモリ管理とチャネルに、チャネルは所有権追跡とスケジューラーに依存します</li>
<li><strong>Subsystems (Native C++)</strong>: COOS
カーネルコンポーネントへの直接依存がありません。すべての通信は CSP
チャネル経由で行われるため、logger・hal などのサブシステムは COOS
の実装詳細に依存しません</li>
<li><strong>Services (WASM プラグイン)</strong>: ユーザーが提供する WASM
サービス実装。プラグイン性により、独立した複数サービスの同時実行が可能です</li>
</ul>
<p>以下は、各コンポーネントの依存関係の詳細です。</p>
<p><strong>COOS Kernel Core（4コンポーネント、相互独立）：</strong></p>
<pre><code>co_sched (Scheduler)
    ├── co_mem (coroutine context allocation)
    └── co_csp (blocked by channels, coordination)

co_csp (CSP Channels)
    ├── co_value (value transfer, ownership)
    └── co_sched (resume blocked coroutines)

co_mem (Memory Manager)
    └── (no dependencies)

co_value (Ownership Tracking)
    └── (no dependencies, header-only template)</code></pre>
<p><strong>Router（DI Container + ルーティング）：</strong></p>
<pre><code>Router (Dependency Injection Container)
    ├── co_csp (CSP channels for all routing)
    ├── co_mem (routing table, component registry)
    ├── logger (component registration logging)
    ├── hal (HAL subsystem)
    ├── debugger (debugger subsystem)
    └── Services (User WASM plugins)

Responsibility:
- URI-based component routing and discovery
- Access control (request verification before routing)
- Component registration and lifecycle management
- Request serialization (型付きKey-Value)
- Star topology management (all components register with Router)
- Route caching via binary search for O(log N) lookup</code></pre>
<p><strong>Subsystems（ネイティブ実装、COOS非依存）：</strong></p>
<pre><code>logger (Logging Subsystem)
    └── Router (route management via IPC)

hal (HAL Subsystem)
    └── Router (route management via IPC)

debugger [Phase 3] (GDB Protocol Subsystem)
    └── Router (route management via IPC)

jit [Future] (JIT Compiler Subsystem)
    └── Router (route management via IPC)</code></pre>
<p><strong>Services（WASM プラグイン、ユーザー実装）：</strong></p>
<pre><code>User Service 1
    └── Router (IPC communication via encoded messages)

User Service N
    └── Router (IPC communication via encoded messages)</code></pre>
<p><strong>重要：</strong> - <strong>Router は DI Container
として機能</strong>。全てのコンポーネント登録・発見がこれを経由 -
<strong>スター型トポロジ</strong>：vSoC、すべての Subsystems、すべての
Services が Router に登録 - <strong>URI
ベースルーティング</strong>：全てのリクエストは Router 経由で URI
から宛先に解決 - <strong>アクセス制御</strong>：Router
が権限管理を行い、不正なリクエストを拒否 - <strong>Request
Serialization</strong>：型付きKey-Value プロトコル は Router が担当 -
<strong>Subsystems と Services
は独立した隔離ヒープを使用</strong>し、メモリ枯渇による相互の影響を防止</p>
<h3 id="runtime-embedded-functionsパフォーマンス最適化設計">2.1
Runtime-Embedded Functions（パフォーマンス最適化設計）</h3>
<p><strong>背景</strong>：基本設計は Router +
型付きKey-Value（柔軟・セキュア）ですが、GPIO トグル（&lt;50
サイクル要件）など<strong>ホットパス操作</strong>は IPC
オーバーヘッド（数千サイクル）を負担できません。</p>
<p><strong>設計原則</strong>：性能クリティカル機能（GPIO、GPU/NEON、Debugger）は
vSoC ランタイム内蔵、非同期操作（Logger、ADC）は Router IPC。これは
Windows GPU カーネルや Android で採用されている標準パターン。</p>
<p><strong>実装例</strong>：gpio_embedded（GPIO 操作）は vSoC 内蔵で
Router 経由なし。offloader_embedded（MMIO マップ）は
Accelerator、Debugger、JIT を統合。vsoc_impl は builtin_* 関数群で WASM
コードから直接呼び出し可能。</p>
<p><strong>性能特性（実行位置と レイテンシ）</strong></p>
<table>
<thead>
<tr class="header">
<th>操作</th>
<th>実行位置</th>
<th>サイクル</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>GPIO write</td>
<td>Runtime-embedded</td>
<td>8-15</td>
</tr>
<tr class="even">
<td>GPU matmul</td>
<td>Runtime-embedded (MMIO)</td>
<td>100-10000+</td>
</tr>
<tr class="odd">
<td>Breakpoint check</td>
<td>Runtime-embedded</td>
<td>&lt;50</td>
</tr>
<tr class="even">
<td>JIT hotpath hint</td>
<td>Runtime-embedded</td>
<td>O(1)</td>
</tr>
<tr class="odd">
<td>Log write</td>
<td>Router enqueue</td>
<td>&lt;5</td>
</tr>
<tr class="even">
<td>ADC read</td>
<td>Router IPC</td>
<td>500-2000</td>
</tr>
<tr class="odd">
<td>File read (local)</td>
<td>HAL direct</td>
<td>50-500</td>
</tr>
<tr class="even">
<td>Service RPC call</td>
<td>Router IPC</td>
<td>500-2000</td>
</tr>
</tbody>
</table>
<p><strong>重要な設計原則</strong>： - <strong>Router +
型付きKey-Value</strong> は外部通信・Services 用として維持 -
<strong>vOffloader</strong>: GPIO/GPU/Debugger/JIT を統合、&lt;50
サイクル要件達成、コルーチン内実行 - <strong>Router IPC</strong>:
ADC・Logger などハードウェア待ち時間が許容可能な操作向け -
<strong>標準パターン</strong>: Android、Windows GPU、組み込み RTOS
で採用</p>
<hr />
<h2 id="data-flow">3. Data Flow</h2>
<p>本セクションは、Fireball
における主要な処理フロー（コルーチンライフサイクル、チャネル通信、メモリ割り当て）を説明します。</p>
<h3 id="coroutine-lifecycle">3.1 Coroutine Lifecycle</h3>
<p>コルーチン：spawn → run/step → done/suspend。各ステップで
co_mem（スタック割り当て）、co_sched（FIFO Ready
Queue）、logger（イベント記録）が連携。</p>
<pre><code>spawn()
  │
  ├─► [Allocate stack]  ◄──── co_mem
  ├─► [Create coroutine_handle] ◄──── C++20 coroutines
  ├─► [Add to ready_queue]
  └─► [Log: coroutine_spawned] ◄──── logger subsystem

run() / step()
  │
  ├─► [Pop from ready_queue]
  ├─► [Log: coroutine_resumed] ◄──── logger subsystem
  ├─► [Execute until co_yield or done]
  │
  ├─► If done:
  │     ├─► [Log: coroutine_completed] ◄──── logger subsystem
  │     ├─► [Deallocate stack] ◄──── co_mem
  │     └─► [Remove from tracking]
  │
  └─► If suspended:
        ├─► [Log: coroutine_suspended] ◄──── logger subsystem
        └─► [Re-add to ready_queue]</code></pre>
<h3 id="channel-communication">3.2 Channel Communication</h3>
<p>CSP
チャネル：唯一の同期・通信メカニズム。Rendezvous（出会い）まで両者ブロック。<code>co_value&lt;T&gt;</code>
で所有権自動移譲（データ競合なし）。</p>
<pre><code>Sender:
  send(value)
    │
    ├─► [Wrap in co_value&lt;T&gt;] ◄──── co_value
    ├─► [Log: channel_send] ◄──── logger subsystem
    │
    ├─► If receiver waiting:
    │     ├─► [Transfer value ownership]
    │     ├─► [Resume receiver] ◄──── co_sched
    │     └─► [Continue sender]
    │
    └─► If no receiver:
          ├─► [Store value in channel]
          ├─► [Add sender to wait queue]
          └─► [co_yield to scheduler] ◄──── co_sched

Receiver:
  recv()
    │
    ├─► [Log: channel_recv] ◄──── logger subsystem
    │
    ├─► If sender waiting:
    │     ├─► [Take value from channel]
    │     ├─► [Transfer ownership] ◄──── co_value
    │     ├─► [Resume sender] ◄──── co_sched
    │     └─► [Return value]
    │
    └─► If no sender:
          ├─► [Add receiver to wait queue]
          ├─► [co_yield to scheduler] ◄──── co_sched
          └─► [When resumed, return value]</code></pre>
<h3 id="memory-allocation">3.3 Memory Allocation</h3>
<p>co_mem（dlmalloc ベース）：各 WASM モジュールが独立 mspace
で隔離。モジュールメモリ枯渇が他に影響しない。Stack は
page-aligned、ガード ページ対応可。</p>
<pre><code>Application Request:
  allocate(size, alignment)
    │
    ├─► [dlmalloc mspace_malloc] ◄──── dlmalloc
    ├─► [Update statistics]
    └─► [Return pointer]

Stack Allocation:
  allocate_stack(size)
    │
    ├─► [Round up to page boundary]
    ├─► [dlmalloc mspace_memalign] ◄──── dlmalloc
    ├─► [Optional: add guard page]
    └─► [Return stack pointer]

Deallocation:
  deallocate(ptr)
    │
    ├─► [dlmalloc mspace_free] ◄──── dlmalloc
    └─► [Update statistics]</code></pre>
<hr />
<h2 id="concurrency-model">4. Concurrency Model</h2>
<p>Fireball：<strong>協調的スケジューリング</strong> + <strong>CSP
同期</strong>。プリエンプティブ割り込みなし、<code>co_yield</code>
で制御譲り合い。WASM は 1000 命令ごとに自動 yield
注入→ゲストはプリエンプティブに見える。</p>
<pre><code>Time ──────────────────────────────────────────────►

Coro A: ████████ (running)
             │ co_yield
             ▼
Coro B:      ████████ (running)
                  │ co_yield
                  ▼
Coro C:           ████████ (running)
                       │ co_yield
                       ▼
Coro A:                ████████ (running)
                            │ ...</code></pre>
<p><strong>Key Points:</strong> - <strong>No preemption</strong>:
コルーチンは明示的に yield するまで実行を続ける - <strong>No
interrupts</strong>:
ハードウェアタイマー割り込みによるコンテキストスイッチなし -
<strong>Deterministic</strong>: 同じ入力 → 常に同じ実行順序</p>
<h3 id="csp-synchronization">4.2 CSP Synchronization</h3>
<p>CSP：チャネル経由の唯一の通信手段。Rendezvous、所有権移譲（データ競合なし）、デッドロック回避。ロック機構なし。</p>
<pre><code>Coro 1:                    Channel:              Coro 2:
                                   │
send(42) ──────────────────────►  │
  (blocks)                         │ [sender_ready]
                                   │
                                   │  ◄────────────── recv()
                                   │                    (blocks)
                                   │
                                   │ [rendezvous!]
                                   │
  (resumes) ◄────────────────────  │
                                   │  ──────────────► (resumes with 42)
                                   │
  (continues)                      │ [idle]           (continues)</code></pre>
<p><strong>Key Points:</strong> - Blocking send/receive: both sides must
meet - No buffering: direct value transfer - Ownership transfer: sender
loses access after send</p>
<hr />
<h2 id="memory-layout">5. Memory Layout</h2>
<p>32 bit アドレス空間： - <strong>0xC0000000～0xFFFFFFFF</strong>:
デバイスメモリ（MMIO） - <strong>0x00000000～0x40000000</strong>:
メインメモリ（.text、.rodata、.data、.bss、ヒープ↑、スタック↓）</p>
<pre><code>0xFFFFFFFF ┌────────────────────────┐
           │    (Reserved/Invalid)  │
0xC0000000 ├────────────────────────┤
           │     Device Memory      │
           │  (UART, GPIO, etc.)    │
0x40000000 ├────────────────────────┤
           │       RAM              │
           │  ┌──────────────────┐  │
           │  │   Heap (dlmalloc)│  │
           │  ├──────────────────┤  │
           │  │   Stacks (↓)     │  │
           │  ├──────────────────┤  │
           │  │   .bss           │  │
           │  ├──────────────────┤  │
           │  │   .data          │  │
           │  └──────────────────┘  │
0x00000000 └────────────────────────┘</code></pre>
<h3 id="coroutine-stack">5.2 Coroutine Stack</h3>
<p>各コルーチン：独立スタック
8-16KB（デフォルト）。高アドレス→低アドレス成長。ガード
ページ（4KB、オプション）でオーバーフロー検出可。</p>
<pre><code>High Address
    ┌────────────────────┐
    │   Guard Page       │ (optional, read-only)
    ├────────────────────┤
    │   Stack Space      │ (grows downward)
    │   ...              │
    │   Local Variables  │
    │   Return Addresses │
    ├────────────────────┤
    │   Stack Pointer    │ ◄─── Current SP
    └────────────────────┘
Low Address</code></pre>
<p><strong>Stack Configuration:</strong> - <strong>Default</strong>: 8KB
- 16KB（カスタマイズ可能） - <strong>Maximum</strong>:
64KB（組み込みシステムの制約） - <strong>Guard Page</strong>:
4KB（サポートされている場合）</p>
<hr />
<h2 id="build-artifacts">6. Build Artifacts</h2>
<p><code>libfireball.a</code>：COOS（co_sched、co_csp、co_mem）、WASM
runtime（module、executor、memory）、Subsystems（logger、hal）、Allocator（dlmalloc）、Utils（backtrace）から構成。</p>
<pre><code>libfireball.a
  ├── coos/
  │   ├── co_sched.o
  │   ├── co_csp.o
  │   ├── co_mem.o
  │   └── coos_kernel.o
  ├── wasm/
  │   ├── module.o
  │   ├── executor.o
  │   └── memory.o
  ├── services/
  │   ├── logger.o
  │   └── hal.o
  ├── allocator/
  │   ├── malloc.o
  │   └── stdcxx_allocator.o
  └── utils/
      └── backtrace.o</code></pre>
<h3 id="executable-structure">6.2 Executable Structure</h3>
<pre><code>fireball (ELF/binary)
  ├── .text (code)
  ├── .rodata (constants)
  ├── .data (initialized data)
  ├── .bss (zero-initialized)
  └── symbol table</code></pre>
<hr />
<h2 id="execution-model">7. Execution Model</h2>
<h3 id="startup-sequence">7.1 Startup Sequence</h3>
<p>起動順序：HAL → Subsystems → COOS kernel → Router → vSoC → WASM
module読込 → 初期コルーチン生成 → イベントループ → シャットダウン。</p>
<pre><code>main()
  │
  ├─► [Initialize HAL]
  ├─► [Initialize Subsystems (logger, hal)]
  ├─► [Create coos_kernel instance]
  ├─► [kernel-&gt;initialize()]
  │     ├─► [Initialize co_mem with dlmalloc]
  │     ├─► [Initialize co_sched]
  │     └─► [Set global kernel instance]
  │
  ├─► [Initialize Router (DI Container)]
  │     └─► [Register component URIs]
  │
  ├─► [Initialize vSoC]
  │     ├─► [Initialize Interpreter (i32 core)]
  │     ├─► [Initialize JIT module (if enabled)]
  │     └─► [Initialize vOffloader (MMIO mapping)]
  │
  ├─► [Load WASM module]
  │     └─► [Verify with Interpreter]
  │
  ├─► [Spawn initial coroutine]
  │     └─► kernel-&gt;get_scheduler()-&gt;spawn(...)
  │
  ├─► [kernel-&gt;run()]
  │     └─► [Event loop until all coroutines complete]
  │
  ├─► [kernel-&gt;shutdown()]
  └─► [Exit]</code></pre>
<h3 id="event-loop-execution">7.2 Event Loop Execution</h3>
<p><code>kernel-&gt;run()</code>：while pending_count &gt;
0、各ステップで step() 実行、yield/done で次へ切り替え。</p>
<pre><code>kernel-&gt;run():
  while scheduler-&gt;pending_count() &gt; 0:
    if not scheduler-&gt;step():
      break

  // All coroutines completed or stopped
  return</code></pre>
<hr />
<h2 id="error-handling">8. Error Handling</h2>
<p>エラー分類： 1. <strong>Assertion Failures</strong>:
所有権違反→スタックトレース出力、abort 2. <strong>Channel
Errors</strong>: 閉じたチャネル送受信→std::nullopt、graceful shutdown 3.
<strong>Memory Errors</strong>: ヒープ枯渇→nullptr返却、呼び出し側で処理
4. <strong>WASM Errors</strong>:
不正命令、スタックオーバーフロー→trap、logger記録</p>
<h3 id="debug-support">8.2 Debug Support</h3>
<ul>
<li><strong>Backtrace</strong>: std::stacktrace
で呼び出しチェーン表示</li>
<li><strong>Event Log</strong>: logger
がコルーチン/チャネル/メモリ操作を記録</li>
<li><strong>Memory Dump</strong>: mspace ごと使用量・断片化表示</li>
<li><strong>Coroutine Dump</strong>:
アクティブコルーチン一覧（ID、ステータス、深度）</li>
</ul>
<hr />
<h2 id="performance-considerations">9. Performance Considerations</h2>
<h3 id="context-switch-cost">9.1 Context Switch Cost</h3>
<pre><code>Context Switch:
  1. Save current coroutine state (~10 instructions)
  2. Pop next coroutine from ready queue (~5 instructions)
  3. Resume coroutine handle (~20 instructions)
  ────────────────────────────────────────────────
  Total: ~35 instructions (~100-200 CPU cycles)</code></pre>
<h3 id="channel-sendreceive-cost">9.2 Channel Send/Receive Cost</h3>
<p><strong>概要：</strong>
チャネル操作のコストは、受信側がすでに待機しているか（fast
path）、新たにブロックする必要があるか（slow
path）で大きく異なります。</p>
<ul>
<li><strong>Fast Path</strong> (受信側待機)：~25 命令（~75-150
サイクル）</li>
<li><strong>Slow Path</strong> (ブロック)：~60 命令（~180-300
サイクル）</li>
</ul>
<h3 id="memory-overhead">9.3 Memory Overhead</h3>
<ul>
<li><strong>Per Coroutine</strong>: ~8-16KB（handle 8B + Stack 8-16KB +
metadata ~64B）</li>
<li><strong>Per Channel</strong>: ~40B + sizeof(T)</li>
</ul>
<hr />
<h2 id="target-device-constraints">10. Target Device Constraints</h2>
<h3 id="platform-target-strategy">Platform Target Strategy</h3>
<p><strong>Tier 1 (RISC-V)</strong>: WCH CH32V307 (144MHz, 96KB SRAM),
T-Head C906 <strong>Tier 2 (Wireless)</strong>: Nordic nRF52840 (64MHz,
256KB RAM), nRF5340 (512KB RAM)</p>
<h3 id="wch-ch32v307-tier-1-primary">10.1 WCH CH32V307 (Tier 1
Primary)</h3>
<pre><code>CPU: RISC-V RV32IMACZicsr @ 144 MHz
RAM: 96 KB SRAM
Flash: 256 KB
Address Space: 32-bit

Constraints:
  - ~60 KB available for application (after system)
  - ~3-5 coroutines max (at 16KB/stack)
  - ~30-50 channels typical
  - Context switch: ~2-3 µs</code></pre>
<h3 id="nordic-nrf52840-tier-2-wireless">10.2 Nordic nRF52840 (Tier 2
Wireless)</h3>
<pre><code>CPU: ARM Cortex-M4 @ 64 MHz
RAM: 256 KB SRAM
Flash: 1 MB
Address Space: 32-bit

Constraints:
  - ~150 KB available for application (after system/BLE)
  - ~8-10 coroutines max (at 16KB/stack)
  - ~80-120 channels typical
  - Context switch: ~3-4 µs</code></pre>
<hr />
<h2 id="architectural-decision-records-adr">Architectural Decision
Records (ADR)</h2>
<h3 id="adr-001-multi-guest-support">ADR-001: Multi-Guest Support</h3>
<p><strong>Decision</strong>:
ランタイムで複数のゲストを実行できるようにする。マルチコア対応はコアごとにランタイムをアフィニティする構成。
<strong>Rationale</strong>:
単一ゲストのみの現状から、将来的な複数のWASMモジュールやサービス実行を可能にするための拡張性確保。マルチコア環境では、各コアに独立したランタイムインスタンスをアフィニティすることで、競合や複雑な同期機構を回避し、性能と安全性を両立させる。</p>
<h3 id="adr-002-isr-safety-mechanism">ADR-002: ISR Safety Mechanism</h3>
<p><strong>Decision</strong>:
HALから割り込みフラグを立て、インタープリタから監視する。ゲストのコンテキストスイッチ時にランタイムがフラグをチェックする。
<strong>Rationale</strong>:
割り込みハンドラ（ISR）からの安全な操作を保証するため、複雑なロック機構やISRセーフなAPI（例:
<code>send_from_isr</code>）を直接提供する代わりに、より軽量なフラグベースのメカニズムを採用する。これにより、ISRの実行時間を最小限に抑えつつ、割り込み起因のイベントをゲスト側で確実に処理できる。</p>
<h3 id="adr-003-memory-partitioning">ADR-003: Memory Partitioning</h3>
<p><strong>Decision</strong>:
ヘッダファイル形式のコンフィグファイルを定義しその中のマクロで容量などは固定する。
<strong>Rationale</strong>:
リソース制約の厳しい組み込みシステムにおいて、動的なメモリパーティショニングのオーバーヘッドを避け、シンプルかつ予測可能なメモリ使用を保証するため。コンフィグファイルによる固定化は、ビルド時にメモリマップを確定させ、ランタイムの複雑性を低減する。</p>
<h3 id="adr-004-maximum-coroutines-configuration">ADR-004: Maximum
Coroutines Configuration</h3>
<p><strong>Decision</strong>:
ヘッダファイル形式のコンフィグファイルを定義しその中のマクロでヒープサイズなどを固定する。
<strong>Rationale</strong>:
コルーチンの最大数を固定することで、スタックや関連リソースの事前割り当てを可能にし、ランタイムでの動的なリソース管理オーバーヘッドを削減する。ヒープサイズも同様に固定することで、メモリフットプリントを最適化し、確定的な動作を保証する。</p>
<h3 id="adr-005-jit-fallback-strategy">ADR-005: JIT Fallback
Strategy</h3>
<p><strong>Decision</strong>:
基本方針はJITコンパイラのレイテンシの最小化である。テンプレートをヒープに展開しパッチを当てる方式。機械語の最適化はしない。レイテンシを小さくすることで原則ホットスポット分析なしフォールバックなしにしたいが実現性は現状不明である。
<strong>Rationale</strong>:
JITコンパイラの導入に伴う遅延を最小限に抑えるため、最適化よりもレイテンシを優先する。その目的は以下の二点に厳格に限定される：
1. <strong>命令のデコードの削除</strong>:
インタプリタの命令デコードオーバーヘッドを排除し、実行効率を向上させる。
2. <strong>分岐予測が外れる可能性が高い分岐の除去</strong>:
高コストな分岐予測ミスを減らし、CPUパイプラインの効率を高める。
生成される機械語は、テンプレートをヒープに展開しパッチを当てる方式で、基本的な算術演算を除き、分岐予測が有効なランタイムAPI呼び出しをコンパイルするのみであり、複雑な機械語最適化は行わない。これにより、シンプルかつ高速なコード生成を実現し、ホットスポット分析やインタプリタへのフォールバックを不要にすることを目指す。この限定されたスコープは、JITの設計リスクを最小限に抑えつつ、その適用範囲を広げることを可能にする。</p>
<h2 id="future-architecture-changes">11. Future Architecture
Changes</h2>
<h3 id="potential-optimizations">11.1 Potential Optimizations</h3>
<ul>
<li><strong>Coroutine Pool</strong>:
フレーム事前割り当て、割り当て/解放オーバーヘッド削減</li>
<li><strong>Stack Overflow Detection</strong>: ガード
ページ/カナリア値で検出</li>
<li><strong>Zero-Copy Channels</strong>: 大メッセージは参照転送</li>
<li><strong>Buffered Channels</strong>: 有界 FIFO
でバースト送信サポート</li>
</ul>
<h3 id="scalability">11.2 Scalability</h3>
<ul>
<li><strong>Multi-core</strong>: コアごと独立スケジューラー</li>
<li><strong>Distributed</strong>:
ネットワークチャネルでリモート通信</li>
<li><strong>Hierarchical</strong>:
親・子カーネル構造で複数インスタンス統合</li>
</ul>
</body>
</html>
